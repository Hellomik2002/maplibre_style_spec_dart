// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by tool/generate_style_code.js

import 'package:maplibre_style_spec/src/_src.dart';
import 'package:maplibre_style_spec/src/expression/definitions/_definitions.dart';

class Zoom extends Expression<num> {
  const Zoom({
    super.type,
  });

  factory Zoom.fromJson(List<dynamic> args) {
    assert(args[0] == 'zoom', 'Invalid expression type: ${args[0]}, expected [zoom]');

    return const Zoom();
  }

  @override
  num evaluate(EvaluationContext context) {
    return zoomExpressionImpl(
      context,
    );
  }
}

class At extends Expression<dynamic> {
  const At({
    required this.index,
    required this.array,
    super.type,
  });

  factory At.fromJson(List<dynamic> args) {
    assert(args[0] == 'at', 'Invalid expression type: ${args[0]}, expected [at]');

    var i = 1;

    // Parse arg0
    Expression<int> arg0;

    arg0 = Expression<int>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<List<dynamic>> arg1;

    arg1 = Expression<List<dynamic>>.fromJson(args[i]);
    i++;

    return At(
      index: arg0,
      array: arg1,
    );
  }

  final Expression<int> index;
  final Expression<List<dynamic>> array;

  @override
  dynamic evaluate(EvaluationContext context) {
    return atExpressionImpl(
      context,
      index,
      array,
    );
  }
}

class In extends Expression<dynamic> {
  const In({
    required this.needle,
    required this.haystack,
    super.type,
  });

  factory In.fromJson(List<dynamic> args) {
    assert(args[0] == 'in', 'Invalid expression type: ${args[0]}, expected [in]');

    var i = 1;

    // Parse arg0
    Expression<dynamic> arg0;

    arg0 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<dynamic> arg1;

    arg1 = Expression<dynamic>.fromJson(args[i]);
    i++;

    return In(
      needle: arg0,
      haystack: arg1,
    );
  }

  final Expression<dynamic> needle;
  final Expression<dynamic> haystack;

  @override
  dynamic evaluate(EvaluationContext context) {
    return inExpressionImpl(
      context,
      needle,
      haystack,
    );
  }
}

class IndexOf extends Expression<dynamic> {
  const IndexOf({
    required this.needle,
    required this.haystack,
    super.type,
  });

  factory IndexOf.fromJson(List<dynamic> args) {
    assert(args[0] == 'index-of', 'Invalid expression type: ${args[0]}, expected [index-of]');

    var i = 1;

    // Parse arg0
    Expression<dynamic> arg0;

    arg0 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<dynamic> arg1;

    arg1 = Expression<dynamic>.fromJson(args[i]);
    i++;

    return IndexOf(
      needle: arg0,
      haystack: arg1,
    );
  }

  final Expression<dynamic> needle;
  final Expression<dynamic> haystack;

  @override
  dynamic evaluate(EvaluationContext context) {
    return indexOfExpression(
      context,
      needle,
      haystack,
    );
  }
}

class Slice extends Expression<dynamic> {
  const Slice({
    required this.input,
    required this.start,
    this.end,
    super.type,
  });

  factory Slice.fromJson(List<dynamic> args) {
    assert(args[0] == 'slice', 'Invalid expression type: ${args[0]}, expected [slice]');

    var i = 1;

    // Parse arg0
    Expression<dynamic> arg0;

    arg0 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<int> arg1;

    arg1 = Expression<int>.fromJson(args[i]);
    i++;

    // Parse arg2
    Expression<int>? arg2;

    if (args.length > 3) {
      arg2 = args[i] != null ? Expression<int>.fromJson(args[i]) : null;
      i++;
    }

    return Slice(
      input: arg0,
      start: arg1,
      end: arg2,
    );
  }

  final Expression<dynamic> input;
  final Expression<int> start;
  final Expression<int>? end;

  @override
  dynamic evaluate(EvaluationContext context) {
    return sliceExpression(
      context,
      input,
      start,
      end,
    );
  }
}

class Get<T> extends Expression<T> {
  const Get({
    required this.key,
    this.object,
    super.type,
  });

  factory Get.fromJson(List<dynamic> args) {
    assert(args[0] == 'get', 'Invalid expression type: ${args[0]}, expected [get]');

    var i = 1;

    // Parse arg0
    Expression<String> arg0;

    arg0 = Expression<String>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<Map<String, dynamic>>? arg1;

    if (args.length > 2) {
      arg1 = args[i] != null ? Expression<Map<String, dynamic>>.fromJson(args[i]) : null;
      i++;
    }

    return Get(
      key: arg0,
      object: arg1,
    );
  }

  final Expression<String> key;
  final Expression<Map<String, dynamic>>? object;

  @override
  T evaluate(EvaluationContext context) {
    return getExpressionImpl(
      context,
      key,
      object,
    );
  }
}

class Has extends Expression<bool> {
  const Has({
    required this.key,
    this.object,
    super.type,
  });

  factory Has.fromJson(List<dynamic> args) {
    assert(args[0] == 'has', 'Invalid expression type: ${args[0]}, expected [has]');

    var i = 1;

    // Parse arg0
    Expression<String> arg0;

    arg0 = Expression<String>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<Map<String, dynamic>>? arg1;

    if (args.length > 2) {
      arg1 = args[i] != null ? Expression<Map<String, dynamic>>.fromJson(args[i]) : null;
      i++;
    }

    return Has(
      key: arg0,
      object: arg1,
    );
  }

  final Expression<String> key;
  final Expression<Map<String, dynamic>>? object;

  @override
  bool evaluate(EvaluationContext context) {
    return hasExpressionImpl(
      context,
      key,
      object,
    );
  }
}

class Length extends Expression<int> {
  const Length({
    required this.value,
    super.type,
  });

  factory Length.fromJson(List<dynamic> args) {
    assert(args[0] == 'length', 'Invalid expression type: ${args[0]}, expected [length]');

    var i = 1;

    // Parse arg0
    Expression<dynamic> arg0;

    arg0 = Expression<dynamic>.fromJson(args[i]);
    i++;

    return Length(
      value: arg0,
    );
  }

  final Expression<dynamic> value;

  @override
  int evaluate(EvaluationContext context) {
    return lengthExpressionImpl(
      context,
      value,
    );
  }
}

class Step<T> extends Expression<T> {
  const Step({
    required this.input,
    required this.minOutput,
    required this.stops,
    super.type,
  });

  factory Step.fromJson(List<dynamic> args) {
    assert(args[0] == 'step', 'Invalid expression type: ${args[0]}, expected [step]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<T> arg1;

    arg1 = Expression<T>.fromJson(args[i]);
    i++;

    // Parse arg2
    List<(num, Expression<T>)> arg2;

    arg2 = [];
    for (; i < args.length - 0; i += 2) {
      arg2.add((
        args[i + 0] as num,
        Expression<T>.fromJson(args[i + 1]),
      ));
    }

    return Step(
      input: arg0,
      minOutput: arg1,
      stops: arg2,
    );
  }

  final Expression<num> input;
  final Expression<T> minOutput;
  final List<(num, Expression<T>)> stops;

  @override
  T evaluate(EvaluationContext context) {
    return stepExpressionImpl(
      context,
      input,
      minOutput,
      stops,
    );
  }
}

class Interpolate<T> extends Expression<T> {
  const Interpolate({
    required this.options,
    required this.input,
    required this.stops,
    super.type,
  });

  factory Interpolate.fromJson(List<dynamic> args) {
    assert(args[0] == 'interpolate', 'Invalid expression type: ${args[0]}, expected [interpolate]');

    var i = 1;

    // Parse arg0
    Object arg0;

    arg0 = args[i] as Object;
    i++;

    // Parse arg1
    Expression<num> arg1;

    arg1 = Expression<num>.fromJson(args[i]);
    i++;

    // Parse arg2
    List<(num, Expression<T>)> arg2;

    arg2 = [];
    for (; i < args.length - 0; i += 2) {
      arg2.add((
        args[i + 0] as num,
        Expression<T>.fromJson(args[i + 1]),
      ));
    }

    return Interpolate(
      options: arg0,
      input: arg1,
      stops: arg2,
    );
  }

  final Object options;
  final Expression<num> input;
  final List<(num, Expression<T>)> stops;

  @override
  T evaluate(EvaluationContext context) {
    return interpolateExpressionImpl(
      context,
      options,
      input,
      stops,
    );
  }
}

class IsSupportedScript extends Expression<bool> {
  const IsSupportedScript({
    required this.value,
    super.type,
  });

  factory IsSupportedScript.fromJson(List<dynamic> args) {
    assert(args[0] == 'is-supported-script', 'Invalid expression type: ${args[0]}, expected [is-supported-script]');

    var i = 1;

    // Parse arg0
    Expression<String> arg0;

    arg0 = Expression<String>.fromJson(args[i]);
    i++;

    return IsSupportedScript(
      value: arg0,
    );
  }

  final Expression<String> value;

  @override
  bool evaluate(EvaluationContext context) {
    return isSupportedScriptExpressionImpl(
      context,
      value,
    );
  }
}

class Upcase extends Expression<String> {
  const Upcase({
    required this.value,
    super.type,
  });

  factory Upcase.fromJson(List<dynamic> args) {
    assert(args[0] == 'upcase', 'Invalid expression type: ${args[0]}, expected [upcase]');

    var i = 1;

    // Parse arg0
    Expression<String> arg0;

    arg0 = Expression<String>.fromJson(args[i]);
    i++;

    return Upcase(
      value: arg0,
    );
  }

  final Expression<String> value;

  @override
  String evaluate(EvaluationContext context) {
    return upcaseExpressionImpl(
      context,
      value,
    );
  }
}

class Downcase extends Expression<String> {
  const Downcase({
    required this.value,
    super.type,
  });

  factory Downcase.fromJson(List<dynamic> args) {
    assert(args[0] == 'downcase', 'Invalid expression type: ${args[0]}, expected [downcase]');

    var i = 1;

    // Parse arg0
    Expression<String> arg0;

    arg0 = Expression<String>.fromJson(args[i]);
    i++;

    return Downcase(
      value: arg0,
    );
  }

  final Expression<String> value;

  @override
  String evaluate(EvaluationContext context) {
    return downcaseExpressionImpl(
      context,
      value,
    );
  }
}

class Concat extends Expression<String> {
  const Concat({
    required this.values,
    super.type,
  });

  factory Concat.fromJson(List<dynamic> args) {
    assert(args[0] == 'concat', 'Invalid expression type: ${args[0]}, expected [concat]');

    var i = 1;

    // Parse arg0
    List<Expression<dynamic>> arg0;

    arg0 = [];
    for (; i < args.length - 0; i += 1) {
      arg0.add(Expression<dynamic>.fromJson(args[i]));
    }

    return Concat(
      values: arg0,
    );
  }

  final List<Expression<dynamic>> values;

  @override
  String evaluate(EvaluationContext context) {
    return concatExpressionImpl(
      context,
      values,
    );
  }
}

class ResolvedLocale extends Expression<String> {
  const ResolvedLocale({
    required this.collator,
    super.type,
  });

  factory ResolvedLocale.fromJson(List<dynamic> args) {
    assert(args[0] == 'resolved-locale', 'Invalid expression type: ${args[0]}, expected [resolved-locale]');

    var i = 1;

    // Parse arg0
    Expression<Collator> arg0;

    arg0 = Expression<Collator>.fromJson(args[i]);
    i++;

    return ResolvedLocale(
      collator: arg0,
    );
  }

  final Expression<Collator> collator;

  @override
  String evaluate(EvaluationContext context) {
    return resolvedLocaleExpressionImpl(
      context,
      collator,
    );
  }
}

class Case<T> extends Expression<T> {
  const Case({
    required this.branches,
    required this.fallback,
    super.type,
  });

  factory Case.fromJson(List<dynamic> args) {
    assert(args[0] == 'case', 'Invalid expression type: ${args[0]}, expected [case]');

    var i = 1;

    // Parse arg0
    List<(Expression<bool>, Expression<T>)> arg0;

    arg0 = [];
    for (; i < args.length - 1; i += 2) {
      arg0.add((
        Expression<bool>.fromJson(args[i + 0]),
        Expression<T>.fromJson(args[i + 1]),
      ));
    }

    // Parse arg1
    Expression<T> arg1;

    arg1 = Expression<T>.fromJson(args[i]);
    i++;

    return Case(
      branches: arg0,
      fallback: arg1,
    );
  }

  final List<(Expression<bool>, Expression<T>)> branches;
  final Expression<T> fallback;

  @override
  T evaluate(EvaluationContext context) {
    return caseExpressionImpl(
      context,
      branches,
      fallback,
    );
  }
}

class Match<T> extends Expression<T> {
  const Match({
    required this.input,
    required this.branches,
    required this.fallback,
    super.type,
  });

  factory Match.fromJson(List<dynamic> args) {
    assert(args[0] == 'match', 'Invalid expression type: ${args[0]}, expected [match]');

    var i = 1;

    // Parse arg0
    Expression<dynamic> arg0;

    arg0 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg1
    List<(dynamic, Expression<T>)> arg1;

    arg1 = [];
    for (; i < args.length - 1; i += 2) {
      arg1.add((
        args[i + 0] as dynamic,
        Expression<T>.fromJson(args[i + 1]),
      ));
    }

    // Parse arg2
    Expression<T> arg2;

    arg2 = Expression<T>.fromJson(args[i]);
    i++;

    return Match(
      input: arg0,
      branches: arg1,
      fallback: arg2,
    );
  }

  final Expression<dynamic> input;
  final List<(dynamic, Expression<T>)> branches;
  final Expression<T> fallback;

  @override
  T evaluate(EvaluationContext context) {
    return matchExpressionImpl(
      context,
      input,
      branches,
      fallback,
    );
  }
}

class Coalesce<T> extends Expression<T> {
  const Coalesce({
    required this.expressions,
    super.type,
  });

  factory Coalesce.fromJson(List<dynamic> args) {
    assert(args[0] == 'coalesce', 'Invalid expression type: ${args[0]}, expected [coalesce]');

    var i = 1;

    // Parse arg0
    List<Expression<T>> arg0;

    arg0 = [];
    for (; i < args.length - 0; i += 1) {
      arg0.add(Expression<T>.fromJson(args[i]));
    }

    return Coalesce(
      expressions: arg0,
    );
  }

  final List<Expression<T>> expressions;

  @override
  T evaluate(EvaluationContext context) {
    return coalesceExpressionImpl(
      context,
      expressions,
    );
  }
}

class Equals extends Expression<bool> {
  const Equals({
    required this.left,
    required this.right,
    this.collator,
    super.type,
  });

  factory Equals.fromJson(List<dynamic> args) {
    assert(args[0] == '==', 'Invalid expression type: ${args[0]}, expected [==]');

    var i = 1;

    // Parse arg0
    Expression<dynamic> arg0;

    arg0 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<dynamic> arg1;

    arg1 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg2
    Expression<Collator>? arg2;

    if (args.length > 3) {
      arg2 = args[i] != null ? Expression<Collator>.fromJson(args[i]) : null;
      i++;
    }

    return Equals(
      left: arg0,
      right: arg1,
      collator: arg2,
    );
  }

  final Expression<dynamic> left;
  final Expression<dynamic> right;
  final Expression<Collator>? collator;

  @override
  bool evaluate(EvaluationContext context) {
    return equalsExpressionImpl(
      context,
      left,
      right,
      collator,
    );
  }
}

class NotEquals extends Expression<bool> {
  const NotEquals({
    required this.left,
    required this.right,
    this.collator,
    super.type,
  });

  factory NotEquals.fromJson(List<dynamic> args) {
    assert(args[0] == '!=', 'Invalid expression type: ${args[0]}, expected [!=]');

    var i = 1;

    // Parse arg0
    Expression<dynamic> arg0;

    arg0 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<dynamic> arg1;

    arg1 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg2
    Expression<Collator>? arg2;

    if (args.length > 3) {
      arg2 = args[i] != null ? Expression<Collator>.fromJson(args[i]) : null;
      i++;
    }

    return NotEquals(
      left: arg0,
      right: arg1,
      collator: arg2,
    );
  }

  final Expression<dynamic> left;
  final Expression<dynamic> right;
  final Expression<Collator>? collator;

  @override
  bool evaluate(EvaluationContext context) {
    return notEqualsExpressionImpl(
      context,
      left,
      right,
      collator,
    );
  }
}

class GreaterThan extends Expression<bool> {
  const GreaterThan({
    required this.left,
    required this.right,
    this.collator,
    super.type,
  });

  factory GreaterThan.fromJson(List<dynamic> args) {
    assert(args[0] == '>', 'Invalid expression type: ${args[0]}, expected [>]');

    var i = 1;

    // Parse arg0
    Expression<dynamic> arg0;

    arg0 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<dynamic> arg1;

    arg1 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg2
    Expression<Collator>? arg2;

    if (args.length > 3) {
      arg2 = args[i] != null ? Expression<Collator>.fromJson(args[i]) : null;
      i++;
    }

    return GreaterThan(
      left: arg0,
      right: arg1,
      collator: arg2,
    );
  }

  final Expression<dynamic> left;
  final Expression<dynamic> right;
  final Expression<Collator>? collator;

  @override
  bool evaluate(EvaluationContext context) {
    return greaterThanExpressionImpl(
      context,
      left,
      right,
      collator,
    );
  }
}

class LessThan extends Expression<bool> {
  const LessThan({
    required this.left,
    required this.right,
    this.collator,
    super.type,
  });

  factory LessThan.fromJson(List<dynamic> args) {
    assert(args[0] == '<', 'Invalid expression type: ${args[0]}, expected [<]');

    var i = 1;

    // Parse arg0
    Expression<dynamic> arg0;

    arg0 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<dynamic> arg1;

    arg1 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg2
    Expression<Collator>? arg2;

    if (args.length > 3) {
      arg2 = args[i] != null ? Expression<Collator>.fromJson(args[i]) : null;
      i++;
    }

    return LessThan(
      left: arg0,
      right: arg1,
      collator: arg2,
    );
  }

  final Expression<dynamic> left;
  final Expression<dynamic> right;
  final Expression<Collator>? collator;

  @override
  bool evaluate(EvaluationContext context) {
    return lessThanExpressionImpl(
      context,
      left,
      right,
      collator,
    );
  }
}

class GreaterThanOrEquals extends Expression<bool> {
  const GreaterThanOrEquals({
    required this.left,
    required this.right,
    this.collator,
    super.type,
  });

  factory GreaterThanOrEquals.fromJson(List<dynamic> args) {
    assert(args[0] == '>=', 'Invalid expression type: ${args[0]}, expected [>=]');

    var i = 1;

    // Parse arg0
    Expression<dynamic> arg0;

    arg0 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<dynamic> arg1;

    arg1 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg2
    Expression<Collator>? arg2;

    if (args.length > 3) {
      arg2 = args[i] != null ? Expression<Collator>.fromJson(args[i]) : null;
      i++;
    }

    return GreaterThanOrEquals(
      left: arg0,
      right: arg1,
      collator: arg2,
    );
  }

  final Expression<dynamic> left;
  final Expression<dynamic> right;
  final Expression<Collator>? collator;

  @override
  bool evaluate(EvaluationContext context) {
    return greaterThanOrEqualsExpressionImpl(
      context,
      left,
      right,
      collator,
    );
  }
}

class LessThanOrEquals extends Expression<bool> {
  const LessThanOrEquals({
    required this.left,
    required this.right,
    this.collator,
    super.type,
  });

  factory LessThanOrEquals.fromJson(List<dynamic> args) {
    assert(args[0] == '<=', 'Invalid expression type: ${args[0]}, expected [<=]');

    var i = 1;

    // Parse arg0
    Expression<dynamic> arg0;

    arg0 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<dynamic> arg1;

    arg1 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg2
    Expression<Collator>? arg2;

    if (args.length > 3) {
      arg2 = args[i] != null ? Expression<Collator>.fromJson(args[i]) : null;
      i++;
    }

    return LessThanOrEquals(
      left: arg0,
      right: arg1,
      collator: arg2,
    );
  }

  final Expression<dynamic> left;
  final Expression<dynamic> right;
  final Expression<Collator>? collator;

  @override
  bool evaluate(EvaluationContext context) {
    return lessThanOrEqualsExpressionImpl(
      context,
      left,
      right,
      collator,
    );
  }
}

class All extends Expression<bool> {
  const All({
    required this.expressions,
    super.type,
  });

  factory All.fromJson(List<dynamic> args) {
    assert(args[0] == 'all', 'Invalid expression type: ${args[0]}, expected [all]');

    var i = 1;

    // Parse arg0
    List<Expression<bool>> arg0;

    arg0 = [];
    for (; i < args.length - 0; i += 1) {
      arg0.add(Expression<bool>.fromJson(args[i]));
    }

    return All(
      expressions: arg0,
    );
  }

  final List<Expression<bool>> expressions;

  @override
  bool evaluate(EvaluationContext context) {
    return allExpressionImpl(
      context,
      expressions,
    );
  }
}

class Any extends Expression<bool> {
  const Any({
    required this.expressions,
    super.type,
  });

  factory Any.fromJson(List<dynamic> args) {
    assert(args[0] == 'any', 'Invalid expression type: ${args[0]}, expected [any]');

    var i = 1;

    // Parse arg0
    List<Expression<bool>> arg0;

    arg0 = [];
    for (; i < args.length - 0; i += 1) {
      arg0.add(Expression<bool>.fromJson(args[i]));
    }

    return Any(
      expressions: arg0,
    );
  }

  final List<Expression<bool>> expressions;

  @override
  bool evaluate(EvaluationContext context) {
    return anyExpressionImpl(
      context,
      expressions,
    );
  }
}

class Not extends Expression<bool> {
  const Not({
    required this.expression,
    super.type,
  });

  factory Not.fromJson(List<dynamic> args) {
    assert(args[0] == '!', 'Invalid expression type: ${args[0]}, expected [!]');

    var i = 1;

    // Parse arg0
    Expression<bool> arg0;

    arg0 = Expression<bool>.fromJson(args[i]);
    i++;

    return Not(
      expression: arg0,
    );
  }

  final Expression<bool> expression;

  @override
  bool evaluate(EvaluationContext context) {
    return notExpressionImpl(
      context,
      expression,
    );
  }
}

class Let<T> extends Expression<T> {
  const Let({
    required this.bindings,
    required this.child,
    super.type,
  });

  factory Let.fromJson(List<dynamic> args) {
    assert(args[0] == 'let', 'Invalid expression type: ${args[0]}, expected [let]');

    var i = 1;

    // Parse arg0
    List<(String, Expression<Object?>)> arg0;

    arg0 = [];
    for (; i < args.length - 1; i += 2) {
      arg0.add((
        args[i + 0] as String,
        Expression<Object?>.fromJson(args[i + 1]),
      ));
    }

    // Parse arg1
    Expression<T> arg1;

    arg1 = Expression<T>.fromJson(args[i]);
    i++;

    return Let(
      bindings: arg0,
      child: arg1,
    );
  }

  final List<(String, Expression<Object?>)> bindings;
  final Expression<T> child;

  @override
  T evaluate(EvaluationContext context) {
    return letExpressionImpl(
      context,
      bindings,
      child,
    );
  }
}

class Var<T> extends Expression<T> {
  const Var({
    required this.name,
    super.type,
  });

  factory Var.fromJson(List<dynamic> args) {
    assert(args[0] == 'var', 'Invalid expression type: ${args[0]}, expected [var]');

    var i = 1;

    // Parse arg0
    String arg0;

    arg0 = args[i] as String;
    i++;

    return Var(
      name: arg0,
    );
  }

  final String name;

  @override
  T evaluate(EvaluationContext context) {
    return varExpressionImpl(
      context,
      name,
    );
  }
}

class Literal<T> extends Expression<T> {
  const Literal({
    required this.value,
    super.type,
  });

  factory Literal.fromJson(List<dynamic> args) {
    return literalExpressionFromJsonImpl(args);
  }

  final T value;

  @override
  T evaluate(EvaluationContext context) {
    return literalExpressionImpl(
      context,
      value,
    );
  }
}

class CollatorExpression extends Expression<Collator> {
  const CollatorExpression({
    required this.object,
    super.type,
  });

  factory CollatorExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'collator', 'Invalid expression type: ${args[0]}, expected [collator]');

    var i = 1;

    // Parse arg0
    ({Expression<bool>? caseSensitive, Expression<bool>? diacriticSensitive, Expression<String>? locale}) arg0;

    arg0 = (
      caseSensitive: args[i]['case-sensitive'] != null ? Expression<bool>.fromJson(args[i]['case-sensitive']) : null,
      diacriticSensitive:
          args[i]['diacritic-sensitive'] != null ? Expression<bool>.fromJson(args[i]['diacritic-sensitive']) : null,
      locale: args[i]['locale'] != null ? Expression<String>.fromJson(args[i]['locale']) : null,
    );
    i++;

    return CollatorExpression(
      object: arg0,
    );
  }

  final ({Expression<bool>? caseSensitive, Expression<bool>? diacriticSensitive, Expression<String>? locale}) object;

  @override
  Collator evaluate(EvaluationContext context) {
    return collatorExpressionImpl(
      context,
      object,
    );
  }
}

class Format extends Expression<Formatted> {
  const Format({
    super.type,
  });

  factory Format.fromJson(List<dynamic> args) {
    assert(args[0] == 'format', 'Invalid expression type: ${args[0]}, expected [format]');

    return const Format();
  }

  @override
  Formatted evaluate(EvaluationContext context) {
    return formatExpressionImpl(
      context,
    );
  }
}

class ImageExpression extends Expression<ResolvedImage> {
  const ImageExpression({
    required this.value,
    super.type,
  });

  factory ImageExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'image', 'Invalid expression type: ${args[0]}, expected [image]');

    var i = 1;

    // Parse arg0
    Expression<String> arg0;

    arg0 = Expression<String>.fromJson(args[i]);
    i++;

    return ImageExpression(
      value: arg0,
    );
  }

  final Expression<String> value;

  @override
  ResolvedImage evaluate(EvaluationContext context) {
    return imageExpressionImpl(
      context,
      value,
    );
  }
}

class NumberFormat extends Expression<String> {
  const NumberFormat({
    required this.number,
    required this.options,
    super.type,
  });

  factory NumberFormat.fromJson(List<dynamic> args) {
    assert(args[0] == 'number-format', 'Invalid expression type: ${args[0]}, expected [number-format]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    // Parse arg1
    ({
      Expression<String>? currency,
      Expression<String>? locale,
      Expression<int>? maxFractionDigits,
      Expression<int>? minFractionDigits
    }) arg1;

    arg1 = (
      currency: args[i]['currency'] != null ? Expression<String>.fromJson(args[i]['currency']) : null,
      locale: args[i]['locale'] != null ? Expression<String>.fromJson(args[i]['locale']) : null,
      maxFractionDigits:
          args[i]['max-fraction-digits'] != null ? Expression<int>.fromJson(args[i]['max-fraction-digits']) : null,
      minFractionDigits:
          args[i]['min-fraction-digits'] != null ? Expression<int>.fromJson(args[i]['min-fraction-digits']) : null,
    );
    i++;

    return NumberFormat(
      number: arg0,
      options: arg1,
    );
  }

  final Expression<num> number;
  final ({
    Expression<String>? currency,
    Expression<String>? locale,
    Expression<int>? maxFractionDigits,
    Expression<int>? minFractionDigits
  }) options;

  @override
  String evaluate(EvaluationContext context) {
    return numberFormatExpressionImpl(
      context,
      number,
      options,
    );
  }
}

class ArrayAssertion extends Expression<List<dynamic>> {
  const ArrayAssertion({
    required this.value,
    this.childType,
    this.childCount,
    super.type,
  });

  factory ArrayAssertion.fromJson(List<dynamic> args) {
    assert(args[0] == 'array', 'Invalid expression type: ${args[0]}, expected [array]');

    var i = 1;

    // Parse arg0
    Expression<dynamic> arg0;

    arg0 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg1
    Type? arg1;

    if (args.length > 2) {
      arg1 = args[i] as Type?;
      i++;
    }

    // Parse arg2
    int? arg2;

    if (args.length > 3) {
      arg2 = args[i] as int?;
      i++;
    }

    return ArrayAssertion(
      value: arg0,
      childType: arg1,
      childCount: arg2,
    );
  }

  final Expression<dynamic> value;
  final Type? childType;
  final int? childCount;

  @override
  List<dynamic> evaluate(EvaluationContext context) {
    return arrayAssertionExpressionImpl(
      context,
      value,
      childType,
      childCount,
    );
  }
}

class BooleanAssertion extends Expression<bool> {
  const BooleanAssertion({
    required this.args,
    super.type,
  });

  factory BooleanAssertion.fromJson(List<dynamic> args) {
    assert(args[0] == 'boolean', 'Invalid expression type: ${args[0]}, expected [boolean]');

    var i = 1;

    // Parse arg0
    List<Expression<dynamic>> arg0;

    arg0 = [];
    for (; i < args.length - 0; i += 1) {
      arg0.add(Expression<dynamic>.fromJson(args[i]));
    }

    return BooleanAssertion(
      args: arg0,
    );
  }

  final List<Expression<dynamic>> args;

  @override
  bool evaluate(EvaluationContext context) {
    return booleanAssertionExpressionImpl(
      context,
      args,
    );
  }
}

class NumberAssertion extends Expression<num> {
  const NumberAssertion({
    required this.args,
    super.type,
  });

  factory NumberAssertion.fromJson(List<dynamic> args) {
    assert(args[0] == 'number', 'Invalid expression type: ${args[0]}, expected [number]');

    var i = 1;

    // Parse arg0
    List<Expression<dynamic>> arg0;

    arg0 = [];
    for (; i < args.length - 0; i += 1) {
      arg0.add(Expression<dynamic>.fromJson(args[i]));
    }

    return NumberAssertion(
      args: arg0,
    );
  }

  final List<Expression<dynamic>> args;

  @override
  num evaluate(EvaluationContext context) {
    return numberAssertionExpressionImpl(
      context,
      args,
    );
  }
}

class StringAssertion extends Expression<String> {
  const StringAssertion({
    required this.args,
    super.type,
  });

  factory StringAssertion.fromJson(List<dynamic> args) {
    assert(args[0] == 'string', 'Invalid expression type: ${args[0]}, expected [string]');

    var i = 1;

    // Parse arg0
    List<Expression<dynamic>> arg0;

    arg0 = [];
    for (; i < args.length - 0; i += 1) {
      arg0.add(Expression<dynamic>.fromJson(args[i]));
    }

    return StringAssertion(
      args: arg0,
    );
  }

  final List<Expression<dynamic>> args;

  @override
  String evaluate(EvaluationContext context) {
    return stringAssertionExpressionImpl(
      context,
      args,
    );
  }
}

class ObjectAssertion extends Expression<Map<String, dynamic>> {
  const ObjectAssertion({
    required this.args,
    super.type,
  });

  factory ObjectAssertion.fromJson(List<dynamic> args) {
    assert(args[0] == 'object', 'Invalid expression type: ${args[0]}, expected [object]');

    var i = 1;

    // Parse arg0
    List<Expression<dynamic>> arg0;

    arg0 = [];
    for (; i < args.length - 0; i += 1) {
      arg0.add(Expression<dynamic>.fromJson(args[i]));
    }

    return ObjectAssertion(
      args: arg0,
    );
  }

  final List<Expression<dynamic>> args;

  @override
  Map<String, dynamic> evaluate(EvaluationContext context) {
    return objectAssertionExpressionImpl(
      context,
      args,
    );
  }
}

class TypeOf extends Expression<String> {
  const TypeOf({
    required this.value,
    super.type,
  });

  factory TypeOf.fromJson(List<dynamic> args) {
    assert(args[0] == 'typeof', 'Invalid expression type: ${args[0]}, expected [typeof]');

    var i = 1;

    // Parse arg0
    Expression<dynamic> arg0;

    arg0 = Expression<dynamic>.fromJson(args[i]);
    i++;

    return TypeOf(
      value: arg0,
    );
  }

  final Expression<dynamic> value;

  @override
  String evaluate(EvaluationContext context) {
    return typeOfExpressionImpl(
      context,
      value,
    );
  }
}

class ToString extends Expression<String> {
  const ToString({
    required this.value,
    super.type,
  });

  factory ToString.fromJson(List<dynamic> args) {
    assert(args[0] == 'to-string', 'Invalid expression type: ${args[0]}, expected [to-string]');

    var i = 1;

    // Parse arg0
    Expression<dynamic> arg0;

    arg0 = Expression<dynamic>.fromJson(args[i]);
    i++;

    return ToString(
      value: arg0,
    );
  }

  final Expression<dynamic> value;

  @override
  String evaluate(EvaluationContext context) {
    return toStringExpressionImpl(
      context,
      value,
    );
  }
}

class ToNumber extends Expression<num> {
  const ToNumber({
    required this.values,
    super.type,
  });

  factory ToNumber.fromJson(List<dynamic> args) {
    assert(args[0] == 'to-number', 'Invalid expression type: ${args[0]}, expected [to-number]');

    var i = 1;

    // Parse arg0
    List<Expression<dynamic>> arg0;

    arg0 = [];
    for (; i < args.length - 0; i += 1) {
      arg0.add(Expression<dynamic>.fromJson(args[i]));
    }

    return ToNumber(
      values: arg0,
    );
  }

  final List<Expression<dynamic>> values;

  @override
  num evaluate(EvaluationContext context) {
    return toNumberExpressionImpl(
      context,
      values,
    );
  }
}

class ToBoolean extends Expression<bool> {
  const ToBoolean({
    required this.value,
    super.type,
  });

  factory ToBoolean.fromJson(List<dynamic> args) {
    assert(args[0] == 'to-boolean', 'Invalid expression type: ${args[0]}, expected [to-boolean]');

    var i = 1;

    // Parse arg0
    Expression<dynamic> arg0;

    arg0 = Expression<dynamic>.fromJson(args[i]);
    i++;

    return ToBoolean(
      value: arg0,
    );
  }

  final Expression<dynamic> value;

  @override
  bool evaluate(EvaluationContext context) {
    return toBooleanExpressionImpl(
      context,
      value,
    );
  }
}

class ToColor extends Expression<Color> {
  const ToColor({
    required this.values,
    super.type,
  });

  factory ToColor.fromJson(List<dynamic> args) {
    assert(args[0] == 'to-color', 'Invalid expression type: ${args[0]}, expected [to-color]');

    var i = 1;

    // Parse arg0
    List<Expression<dynamic>> arg0;

    arg0 = [];
    for (; i < args.length - 0; i += 1) {
      arg0.add(Expression<dynamic>.fromJson(args[i]));
    }

    return ToColor(
      values: arg0,
    );
  }

  final List<Expression<dynamic>> values;

  @override
  Color evaluate(EvaluationContext context) {
    return toColorExpressionImpl(
      context,
      values,
    );
  }
}

class ToRgba extends Expression<List<num>> {
  const ToRgba({
    required this.value,
    super.type,
  });

  factory ToRgba.fromJson(List<dynamic> args) {
    assert(args[0] == 'to-rgba', 'Invalid expression type: ${args[0]}, expected [to-rgba]');

    var i = 1;

    // Parse arg0
    Expression<Color> arg0;

    arg0 = Expression<Color>.fromJson(args[i]);
    i++;

    return ToRgba(
      value: arg0,
    );
  }

  final Expression<Color> value;

  @override
  List<num> evaluate(EvaluationContext context) {
    return toRgbaExpressionImpl(
      context,
      value,
    );
  }
}

class Rgb extends Expression<Color> {
  const Rgb({
    required this.r,
    required this.g,
    required this.b,
    super.type,
  });

  factory Rgb.fromJson(List<dynamic> args) {
    assert(args[0] == 'rgb', 'Invalid expression type: ${args[0]}, expected [rgb]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<num> arg1;

    arg1 = Expression<num>.fromJson(args[i]);
    i++;

    // Parse arg2
    Expression<num> arg2;

    arg2 = Expression<num>.fromJson(args[i]);
    i++;

    return Rgb(
      r: arg0,
      g: arg1,
      b: arg2,
    );
  }

  final Expression<num> r;
  final Expression<num> g;
  final Expression<num> b;

  @override
  Color evaluate(EvaluationContext context) {
    return rgbExpressionImpl(
      context,
      r,
      g,
      b,
    );
  }
}

class Rgba extends Expression<Color> {
  const Rgba({
    required this.r,
    required this.g,
    required this.b,
    required this.a,
    super.type,
  });

  factory Rgba.fromJson(List<dynamic> args) {
    assert(args[0] == 'rgba', 'Invalid expression type: ${args[0]}, expected [rgba]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<num> arg1;

    arg1 = Expression<num>.fromJson(args[i]);
    i++;

    // Parse arg2
    Expression<num> arg2;

    arg2 = Expression<num>.fromJson(args[i]);
    i++;

    // Parse arg3
    Expression<num> arg3;

    arg3 = Expression<num>.fromJson(args[i]);
    i++;

    return Rgba(
      r: arg0,
      g: arg1,
      b: arg2,
      a: arg3,
    );
  }

  final Expression<num> r;
  final Expression<num> g;
  final Expression<num> b;
  final Expression<num> a;

  @override
  Color evaluate(EvaluationContext context) {
    return rgbaExpressionImpl(
      context,
      r,
      g,
      b,
      a,
    );
  }
}

class Properties extends Expression<Map<String, dynamic>> {
  const Properties({
    super.type,
  });

  factory Properties.fromJson(List<dynamic> args) {
    assert(args[0] == 'properties', 'Invalid expression type: ${args[0]}, expected [properties]');

    return const Properties();
  }

  @override
  Map<String, dynamic> evaluate(EvaluationContext context) {
    return propertiesExpressionImpl(
      context,
    );
  }
}

class FeatureState extends Expression<dynamic> {
  const FeatureState({
    required this.key,
    super.type,
  });

  factory FeatureState.fromJson(List<dynamic> args) {
    assert(args[0] == 'feature-state', 'Invalid expression type: ${args[0]}, expected [feature-state]');

    var i = 1;

    // Parse arg0
    Expression<String> arg0;

    arg0 = Expression<String>.fromJson(args[i]);
    i++;

    return FeatureState(
      key: arg0,
    );
  }

  final Expression<String> key;

  @override
  dynamic evaluate(EvaluationContext context) {
    return featureStateExpressionImpl(
      context,
      key,
    );
  }
}

class GeometryType extends Expression<String> {
  const GeometryType({
    super.type,
  });

  factory GeometryType.fromJson(List<dynamic> args) {
    assert(args[0] == 'geometry-type', 'Invalid expression type: ${args[0]}, expected [geometry-type]');

    return const GeometryType();
  }

  @override
  String evaluate(EvaluationContext context) {
    return geometryTypeExpressionImpl(
      context,
    );
  }
}

class Id extends Expression<String?> {
  const Id({
    super.type,
  });

  factory Id.fromJson(List<dynamic> args) {
    assert(args[0] == 'id', 'Invalid expression type: ${args[0]}, expected [id]');

    return const Id();
  }

  @override
  String? evaluate(EvaluationContext context) {
    return idExpressionImpl(
      context,
    );
  }
}

class LineProgress extends Expression<double> {
  const LineProgress({
    super.type,
  });

  factory LineProgress.fromJson(List<dynamic> args) {
    assert(args[0] == 'line-progress', 'Invalid expression type: ${args[0]}, expected [line-progress]');

    return const LineProgress();
  }

  @override
  double evaluate(EvaluationContext context) {
    return lineProgressExpressionImpl(
      context,
    );
  }
}

class Accumulated extends Expression<double> {
  const Accumulated({
    required this.key,
    super.type,
  });

  factory Accumulated.fromJson(List<dynamic> args) {
    assert(args[0] == 'accumulated', 'Invalid expression type: ${args[0]}, expected [accumulated]');

    var i = 1;

    // Parse arg0
    Expression<String> arg0;

    arg0 = Expression<String>.fromJson(args[i]);
    i++;

    return Accumulated(
      key: arg0,
    );
  }

  final Expression<String> key;

  @override
  double evaluate(EvaluationContext context) {
    return accumulatedExpressionImpl(
      context,
      key,
    );
  }
}

class Ln2 extends Expression<num> {
  const Ln2({
    super.type,
  });

  factory Ln2.fromJson(List<dynamic> args) {
    assert(args[0] == 'ln2', 'Invalid expression type: ${args[0]}, expected [ln2]');

    return const Ln2();
  }

  @override
  num evaluate(EvaluationContext context) {
    return ln2ExpressionImpl(
      context,
    );
  }
}

class Pi extends Expression<num> {
  const Pi({
    super.type,
  });

  factory Pi.fromJson(List<dynamic> args) {
    assert(args[0] == 'pi', 'Invalid expression type: ${args[0]}, expected [pi]');

    return const Pi();
  }

  @override
  num evaluate(EvaluationContext context) {
    return piExpressionImpl(
      context,
    );
  }
}

class E extends Expression<num> {
  const E({
    super.type,
  });

  factory E.fromJson(List<dynamic> args) {
    assert(args[0] == 'e', 'Invalid expression type: ${args[0]}, expected [e]');

    return const E();
  }

  @override
  num evaluate(EvaluationContext context) {
    return eExpressionImpl(
      context,
    );
  }
}

class Add extends Expression<num> {
  const Add({
    required this.args,
    super.type,
  });

  factory Add.fromJson(List<dynamic> args) {
    assert(args[0] == '+', 'Invalid expression type: ${args[0]}, expected [+]');

    var i = 1;

    // Parse arg0
    List<Expression<num>> arg0;

    arg0 = [];
    for (; i < args.length - 0; i += 1) {
      arg0.add(Expression<num>.fromJson(args[i]));
    }

    return Add(
      args: arg0,
    );
  }

  final List<Expression<num>> args;

  @override
  num evaluate(EvaluationContext context) {
    return addExpressionImpl(
      context,
      args,
    );
  }
}

class Multiply extends Expression<num> {
  const Multiply({
    required this.args,
    super.type,
  });

  factory Multiply.fromJson(List<dynamic> args) {
    assert(args[0] == '*', 'Invalid expression type: ${args[0]}, expected [*]');

    var i = 1;

    // Parse arg0
    List<Expression<num>> arg0;

    arg0 = [];
    for (; i < args.length - 0; i += 1) {
      arg0.add(Expression<num>.fromJson(args[i]));
    }

    return Multiply(
      args: arg0,
    );
  }

  final List<Expression<num>> args;

  @override
  num evaluate(EvaluationContext context) {
    return multiplyExpressionImpl(
      context,
      args,
    );
  }
}

class Minus extends Expression<num> {
  const Minus({
    required this.left,
    this.right,
    super.type,
  });

  factory Minus.fromJson(List<dynamic> args) {
    assert(args[0] == '-', 'Invalid expression type: ${args[0]}, expected [-]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<num>? arg1;

    if (args.length > 2) {
      arg1 = args[i] != null ? Expression<num>.fromJson(args[i]) : null;
      i++;
    }

    return Minus(
      left: arg0,
      right: arg1,
    );
  }

  final Expression<num> left;
  final Expression<num>? right;

  @override
  num evaluate(EvaluationContext context) {
    return minusExpressionImpl(
      context,
      left,
      right,
    );
  }
}

class Divide extends Expression<num> {
  const Divide({
    required this.left,
    required this.right,
    super.type,
  });

  factory Divide.fromJson(List<dynamic> args) {
    assert(args[0] == '/', 'Invalid expression type: ${args[0]}, expected [/]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<num> arg1;

    arg1 = Expression<num>.fromJson(args[i]);
    i++;

    return Divide(
      left: arg0,
      right: arg1,
    );
  }

  final Expression<num> left;
  final Expression<num> right;

  @override
  num evaluate(EvaluationContext context) {
    return divideExpressionImpl(
      context,
      left,
      right,
    );
  }
}

class Mod extends Expression<num> {
  const Mod({
    required this.left,
    required this.right,
    super.type,
  });

  factory Mod.fromJson(List<dynamic> args) {
    assert(args[0] == '%', 'Invalid expression type: ${args[0]}, expected [%]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<num> arg1;

    arg1 = Expression<num>.fromJson(args[i]);
    i++;

    return Mod(
      left: arg0,
      right: arg1,
    );
  }

  final Expression<num> left;
  final Expression<num> right;

  @override
  num evaluate(EvaluationContext context) {
    return modExpressionImpl(
      context,
      left,
      right,
    );
  }
}

class Pow extends Expression<num> {
  const Pow({
    required this.base,
    required this.exponent,
    super.type,
  });

  factory Pow.fromJson(List<dynamic> args) {
    assert(args[0] == '^', 'Invalid expression type: ${args[0]}, expected [^]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<num> arg1;

    arg1 = Expression<num>.fromJson(args[i]);
    i++;

    return Pow(
      base: arg0,
      exponent: arg1,
    );
  }

  final Expression<num> base;
  final Expression<num> exponent;

  @override
  num evaluate(EvaluationContext context) {
    return powExpressionImpl(
      context,
      base,
      exponent,
    );
  }
}

class Sqrt extends Expression<num> {
  const Sqrt({
    required this.value,
    super.type,
  });

  factory Sqrt.fromJson(List<dynamic> args) {
    assert(args[0] == 'sqrt', 'Invalid expression type: ${args[0]}, expected [sqrt]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    return Sqrt(
      value: arg0,
    );
  }

  final Expression<num> value;

  @override
  num evaluate(EvaluationContext context) {
    return sqrtExpressionImpl(
      context,
      value,
    );
  }
}

class Log10 extends Expression<num> {
  const Log10({
    required this.value,
    super.type,
  });

  factory Log10.fromJson(List<dynamic> args) {
    assert(args[0] == 'log10', 'Invalid expression type: ${args[0]}, expected [log10]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    return Log10(
      value: arg0,
    );
  }

  final Expression<num> value;

  @override
  num evaluate(EvaluationContext context) {
    return log10ExpressionImpl(
      context,
      value,
    );
  }
}

class Ln extends Expression<num> {
  const Ln({
    required this.value,
    super.type,
  });

  factory Ln.fromJson(List<dynamic> args) {
    assert(args[0] == 'ln', 'Invalid expression type: ${args[0]}, expected [ln]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    return Ln(
      value: arg0,
    );
  }

  final Expression<num> value;

  @override
  num evaluate(EvaluationContext context) {
    return lnExpressionImpl(
      context,
      value,
    );
  }
}

class Log2 extends Expression<num> {
  const Log2({
    required this.value,
    super.type,
  });

  factory Log2.fromJson(List<dynamic> args) {
    assert(args[0] == 'log2', 'Invalid expression type: ${args[0]}, expected [log2]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    return Log2(
      value: arg0,
    );
  }

  final Expression<num> value;

  @override
  num evaluate(EvaluationContext context) {
    return log2ExpressionImpl(
      context,
      value,
    );
  }
}

class Sin extends Expression<num> {
  const Sin({
    required this.value,
    super.type,
  });

  factory Sin.fromJson(List<dynamic> args) {
    assert(args[0] == 'sin', 'Invalid expression type: ${args[0]}, expected [sin]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    return Sin(
      value: arg0,
    );
  }

  final Expression<num> value;

  @override
  num evaluate(EvaluationContext context) {
    return sinExpressionImpl(
      context,
      value,
    );
  }
}

class Cos extends Expression<num> {
  const Cos({
    required this.value,
    super.type,
  });

  factory Cos.fromJson(List<dynamic> args) {
    assert(args[0] == 'cos', 'Invalid expression type: ${args[0]}, expected [cos]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    return Cos(
      value: arg0,
    );
  }

  final Expression<num> value;

  @override
  num evaluate(EvaluationContext context) {
    return cosExpressionImpl(
      context,
      value,
    );
  }
}

class Tan extends Expression<num> {
  const Tan({
    required this.value,
    super.type,
  });

  factory Tan.fromJson(List<dynamic> args) {
    assert(args[0] == 'tan', 'Invalid expression type: ${args[0]}, expected [tan]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    return Tan(
      value: arg0,
    );
  }

  final Expression<num> value;

  @override
  num evaluate(EvaluationContext context) {
    return tanExpressionImpl(
      context,
      value,
    );
  }
}

class Asin extends Expression<num> {
  const Asin({
    required this.value,
    super.type,
  });

  factory Asin.fromJson(List<dynamic> args) {
    assert(args[0] == 'asin', 'Invalid expression type: ${args[0]}, expected [asin]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    return Asin(
      value: arg0,
    );
  }

  final Expression<num> value;

  @override
  num evaluate(EvaluationContext context) {
    return asinExpressionImpl(
      context,
      value,
    );
  }
}

class Acos extends Expression<num> {
  const Acos({
    required this.value,
    super.type,
  });

  factory Acos.fromJson(List<dynamic> args) {
    assert(args[0] == 'acos', 'Invalid expression type: ${args[0]}, expected [acos]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    return Acos(
      value: arg0,
    );
  }

  final Expression<num> value;

  @override
  num evaluate(EvaluationContext context) {
    return acosExpressionImpl(
      context,
      value,
    );
  }
}

class Atan extends Expression<num> {
  const Atan({
    required this.value,
    super.type,
  });

  factory Atan.fromJson(List<dynamic> args) {
    assert(args[0] == 'atan', 'Invalid expression type: ${args[0]}, expected [atan]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    return Atan(
      value: arg0,
    );
  }

  final Expression<num> value;

  @override
  num evaluate(EvaluationContext context) {
    return atanExpressionImpl(
      context,
      value,
    );
  }
}

class Min extends Expression<num> {
  const Min({
    required this.args,
    super.type,
  });

  factory Min.fromJson(List<dynamic> args) {
    assert(args[0] == 'min', 'Invalid expression type: ${args[0]}, expected [min]');

    var i = 1;

    // Parse arg0
    List<Expression<num>> arg0;

    arg0 = [];
    for (; i < args.length - 0; i += 1) {
      arg0.add(Expression<num>.fromJson(args[i]));
    }

    return Min(
      args: arg0,
    );
  }

  final List<Expression<num>> args;

  @override
  num evaluate(EvaluationContext context) {
    return minExpressionImpl(
      context,
      args,
    );
  }
}

class Max extends Expression<num> {
  const Max({
    required this.args,
    super.type,
  });

  factory Max.fromJson(List<dynamic> args) {
    assert(args[0] == 'max', 'Invalid expression type: ${args[0]}, expected [max]');

    var i = 1;

    // Parse arg0
    List<Expression<num>> arg0;

    arg0 = [];
    for (; i < args.length - 0; i += 1) {
      arg0.add(Expression<num>.fromJson(args[i]));
    }

    return Max(
      args: arg0,
    );
  }

  final List<Expression<num>> args;

  @override
  num evaluate(EvaluationContext context) {
    return maxExpressionImpl(
      context,
      args,
    );
  }
}

class Abs extends Expression<num> {
  const Abs({
    required this.value,
    super.type,
  });

  factory Abs.fromJson(List<dynamic> args) {
    assert(args[0] == 'abs', 'Invalid expression type: ${args[0]}, expected [abs]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    return Abs(
      value: arg0,
    );
  }

  final Expression<num> value;

  @override
  num evaluate(EvaluationContext context) {
    return absExpressionImpl(
      context,
      value,
    );
  }
}

class Round extends Expression<num> {
  const Round({
    required this.value,
    super.type,
  });

  factory Round.fromJson(List<dynamic> args) {
    assert(args[0] == 'round', 'Invalid expression type: ${args[0]}, expected [round]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    return Round(
      value: arg0,
    );
  }

  final Expression<num> value;

  @override
  num evaluate(EvaluationContext context) {
    return roundExpressionImpl(
      context,
      value,
    );
  }
}

class Ceil extends Expression<num> {
  const Ceil({
    required this.value,
    super.type,
  });

  factory Ceil.fromJson(List<dynamic> args) {
    assert(args[0] == 'ceil', 'Invalid expression type: ${args[0]}, expected [ceil]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    return Ceil(
      value: arg0,
    );
  }

  final Expression<num> value;

  @override
  num evaluate(EvaluationContext context) {
    return ceilExpressionImpl(
      context,
      value,
    );
  }
}

class Floor extends Expression<num> {
  const Floor({
    required this.value,
    super.type,
  });

  factory Floor.fromJson(List<dynamic> args) {
    assert(args[0] == 'floor', 'Invalid expression type: ${args[0]}, expected [floor]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    return Floor(
      value: arg0,
    );
  }

  final Expression<num> value;

  @override
  num evaluate(EvaluationContext context) {
    return floorExpressionImpl(
      context,
      value,
    );
  }
}

Expression<T> expressionFromJson<T>(List<dynamic> args) {
  return switch (args[0] as String) {
    'zoom' => Zoom.fromJson(args),
    'at' => At.fromJson(args),
    'in' => In.fromJson(args),
    'index-of' => IndexOf.fromJson(args),
    'slice' => Slice.fromJson(args),
    'get' => Get<T>.fromJson(args),
    'has' => Has.fromJson(args),
    'length' => Length.fromJson(args),
    'step' => Step<T>.fromJson(args),
    'interpolate' => Interpolate<T>.fromJson(args),
    'is-supported-script' => IsSupportedScript.fromJson(args),
    'upcase' => Upcase.fromJson(args),
    'downcase' => Downcase.fromJson(args),
    'concat' => Concat.fromJson(args),
    'resolved-locale' => ResolvedLocale.fromJson(args),
    'case' => Case<T>.fromJson(args),
    'match' => Match<T>.fromJson(args),
    'coalesce' => Coalesce<T>.fromJson(args),
    '==' => Equals.fromJson(args),
    '!=' => NotEquals.fromJson(args),
    '>' => GreaterThan.fromJson(args),
    '<' => LessThan.fromJson(args),
    '>=' => GreaterThanOrEquals.fromJson(args),
    '<=' => LessThanOrEquals.fromJson(args),
    'all' => All.fromJson(args),
    'any' => Any.fromJson(args),
    '!' => Not.fromJson(args),
    'let' => Let<T>.fromJson(args),
    'var' => Var<T>.fromJson(args),
    'literal' => Literal<T>.fromJson(args),
    'collator' => CollatorExpression.fromJson(args),
    'format' => Format.fromJson(args),
    'image' => ImageExpression.fromJson(args),
    'number-format' => NumberFormat.fromJson(args),
    'array' => ArrayAssertion.fromJson(args),
    'boolean' => BooleanAssertion.fromJson(args),
    'number' => NumberAssertion.fromJson(args),
    'string' => StringAssertion.fromJson(args),
    'object' => ObjectAssertion.fromJson(args),
    'typeof' => TypeOf.fromJson(args),
    'to-string' => ToString.fromJson(args),
    'to-number' => ToNumber.fromJson(args),
    'to-boolean' => ToBoolean.fromJson(args),
    'to-color' => ToColor.fromJson(args),
    'to-rgba' => ToRgba.fromJson(args),
    'rgb' => Rgb.fromJson(args),
    'rgba' => Rgba.fromJson(args),
    'properties' => Properties.fromJson(args),
    'feature-state' => FeatureState.fromJson(args),
    'geometry-type' => GeometryType.fromJson(args),
    'id' => Id.fromJson(args),
    'line-progress' => LineProgress.fromJson(args),
    'accumulated' => Accumulated.fromJson(args),
    'ln2' => Ln2.fromJson(args),
    'pi' => Pi.fromJson(args),
    'e' => E.fromJson(args),
    '+' => Add.fromJson(args),
    '*' => Multiply.fromJson(args),
    '-' => Minus.fromJson(args),
    '/' => Divide.fromJson(args),
    '%' => Mod.fromJson(args),
    '^' => Pow.fromJson(args),
    'sqrt' => Sqrt.fromJson(args),
    'log10' => Log10.fromJson(args),
    'ln' => Ln.fromJson(args),
    'log2' => Log2.fromJson(args),
    'sin' => Sin.fromJson(args),
    'cos' => Cos.fromJson(args),
    'tan' => Tan.fromJson(args),
    'asin' => Asin.fromJson(args),
    'acos' => Acos.fromJson(args),
    'atan' => Atan.fromJson(args),
    'min' => Min.fromJson(args),
    'max' => Max.fromJson(args),
    'abs' => Abs.fromJson(args),
    'round' => Round.fromJson(args),
    'ceil' => Ceil.fromJson(args),
    'floor' => Floor.fromJson(args),
    _ => throw Exception('Unknown expression type: ${args[0]}'),
  } as Expression<T>;
}
